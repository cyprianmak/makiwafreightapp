  <script>
    // API-based implementation for MakiwaFreight App
    (function() {
      'use strict';
      
      // Configuration
      const API_BASE = 'https://makiwafreight.onrender.com/api'; // Base URL for your API endpoints
      const ADMIN_EMAIL = 'cyprianmak@gmail.com';
      const ADMIN_PASS = 'Muchandida@1';
      const LOAD_EXPIRY_DAYS = 7;
      
      // Page definitions for access control
      const PAGES = {
        'shipper-dashboard': { name: 'Shipper Dashboard', roles: ['shipper'] },
        'shipper-post': { name: 'Post Load', roles: ['shipper'] },
        'shipper-profile': { name: 'Shipper Profile', roles: ['shipper'] },
        'transporter-dashboard': { name: 'Transporter Dashboard', roles: ['transporter'] },
        'transporter-profile': { name: 'Transporter Profile', roles: ['transporter'] },
        'market': { name: 'Market', roles: ['shipper', 'transporter'] },
        'messages': { name: 'Messages', roles: ['shipper', 'transporter'] },
        'control': { name: 'Admin Control', roles: ['admin'] }
      };
      
      // Utility functions
      const now = () => new Date().toISOString();
      const el = id => document.getElementById(id);
      const setText = (id, txt) => { const e = el(id); if(e) e.textContent = txt; };
      const setHidden = (id, hid) => { const e = el(id); if(e) e.classList[hid ? 'add' : 'remove']('hidden'); };
      
      // Sanitize input to prevent XSS
      const sanitize = str => {
        if (!str) return '';
        return str.toString()
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#039;');
      };
      
      // Validate email format
      const isValidEmail = email => {
        const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return re.test(email);
      };
      
      // Error handling wrapper
      const handleError = (fn, fallbackMsg = 'An error occurred') => {
        try {
          return fn();
        } catch (error) {
          console.error('MakiwaFreight Error:', error);
          alert(fallbackMsg + ': ' + error.message);
          return null;
        }
      };
      
      // Calculate expiry date (7 days from now)
      const calculateExpiryDate = () => {
        const expiryDate = new Date();
        expiryDate.setDate(expiryDate.getDate() + LOAD_EXPIRY_DAYS);
        return expiryDate.toISOString();
      };
      
      // Check if a load has expired
      const isLoadExpired = load => {
        if (!load.expires_at) return false;
        return new Date(load.expires_at) < new Date();
      };
      
      // API helper functions
      const apiRequest = async (endpoint, options = {}) => {
        const token = localStorage.getItem('authToken');
        const headers = {
          'Content-Type': 'application/json',
          ...(token && { Authorization: `Bearer ${token}` }),
          ...options.headers
        };
        
        const response = await fetch(`${API_BASE}${endpoint}`, {
          ...options,
          headers
        });
        
        if (!response.ok) {
          const error = await response.json().catch(() => ({}));
          throw new Error(error.message || `API error: ${response.status}`);
        }
        
        return response.json();
      };
      
      // Authentication API functions
      const login = async (email, password) => {
        if (!email || !password) return null;
        
        email = email.trim().toLowerCase();
        const response = await apiRequest('/auth/login', {
          method: 'POST',
          body: JSON.stringify({ email, password })
        });
        
        if (response.token) {
          localStorage.setItem('authToken', response.token);
          return response.user;
        }
        
        return null;
      };
      
      const logout = () => {
        localStorage.removeItem('authToken');
        location.hash = '#login';
        render();
      };
      
      const getCurrentUser = async () => {
        try {
          return await apiRequest('/users/me');
        } catch (error) {
          return null;
        }
      };
      
      // User API functions
      const registerUser = async (data) => {
        // Validate required fields
        if (!data.name || !data.email || !data.password || !data.phone) {
          throw new Error('All required fields must be filled');
        }
        
        if (!isValidEmail(data.email)) {
          throw new Error('Please enter a valid email address');
        }
        
        // Sanitize inputs
        const sanitizedData = {
          name: sanitize(data.name),
          company: sanitize(data.company || ''),
          email: data.email.trim().toLowerCase(),
          phone: sanitize(data.phone),
          password: data.password, // Don't sanitize password
          address: sanitize(data.address || ''),
          role: data.role,
          vehicle_info: sanitize(data.vehicle_info || '')
        };
        
        return await apiRequest('/users', {
          method: 'POST',
          body: JSON.stringify(sanitizedData)
        });
      };
      
      const updateUserProfile = async (userId, profileData) => {
        if (!userId || !profileData) throw new Error('User ID and profile data are required');
        
        // Only allow updating specific fields: name, phone, address, and password
        const allowedFields = ['name', 'phone', 'address', 'password'];
        const sanitizedData = {};
        
        for (const key in profileData) {
          if (allowedFields.includes(key)) {
            if (key === 'password') {
              sanitizedData[key] = profileData[key]; // Don't sanitize password
            } else {
              sanitizedData[key] = sanitize(profileData[key]);
            }
          }
        }
        
        return await apiRequest(`/users/${userId}`, {
          method: 'PUT',
          body: JSON.stringify(sanitizedData)
        });
      };
      
      // Load API functions
      const postLoad = async (payload) => {
        // Validate required fields
        if (!payload.origin || !payload.destination || !payload.date || !payload.cargo_type || !payload.weight) {
          throw new Error('All required fields must be filled');
        }
        
        // Sanitize inputs
        const sanitizedPayload = {
          origin: sanitize(payload.origin),
          destination: sanitize(payload.destination),
          date: payload.date,
          cargo_type: sanitize(payload.cargo_type),
          weight: parseFloat(payload.weight),
          notes: sanitize(payload.notes || '')
        };
        
        return await apiRequest('/loads', {
          method: 'POST',
          body: JSON.stringify(sanitizedPayload)
        });
      };
      
      const getLoads = async (filters = {}) => {
        const params = new URLSearchParams();
        if (filters.origin) params.append('origin', filters.origin);
        if (filters.destination) params.append('destination', filters.destination);
        if (filters.shipper_id) params.append('shipper_id', filters.shipper_id);
        
        const endpoint = `/loads${params.toString() ? `?${params.toString()}` : ''}`;
        return await apiRequest(endpoint);
      };
      
      const updateLoad = async (loadId, patch) => {
        if (!loadId) throw new Error('Load ID is required');
        
        // Sanitize patch values
        const sanitizedPatch = {};
        for (const key in patch) {
          if (key === 'weight') {
            sanitizedPatch[key] = parseFloat(patch[key]);
          } else {
            sanitizedPatch[key] = sanitize(patch[key]);
          }
        }
        
        return await apiRequest(`/loads/${loadId}`, {
          method: 'PUT',
          body: JSON.stringify(sanitizedPatch)
        });
      };
      
      const deleteLoad = async (loadId) => {
        if (!loadId) throw new Error('Load ID is required');
        return await apiRequest(`/loads/${loadId}`, {
          method: 'DELETE'
        });
      };
      
      // Message API functions
      const sendMessage = async (toEmail, body) => {
        if (!toEmail || !body) {
          throw new Error('Recipient and message are required');
        }
        
        if (!isValidEmail(toEmail)) {
          throw new Error('Please enter a valid recipient email');
        }
        
        const sanitizedBody = sanitize(body);
        return await apiRequest('/messages', {
          method: 'POST',
          body: JSON.stringify({ to: toEmail, body: sanitizedBody })
        });
      };
      
      const getMessages = async () => {
        return await apiRequest('/messages');
      };
      
      const deleteMessage = async (messageId) => {
        if (!messageId) throw new Error('Message ID is required');
        return await apiRequest(`/messages/${messageId}`, {
          method: 'DELETE'
        });
      };
      
      // Admin API functions
      const isAdmin = u => u && u.role === 'admin';
      
      const getUsers = async () => {
        return await apiRequest('/admin/users');
      };
      
      const deleteUser = async (email) => {
        if (!email) throw new Error('Email is required');
        return await apiRequest(`/admin/users/${encodeURIComponent(email)}`, {
          method: 'DELETE'
        });
      };
      
      const resetPassword = async (email, newPass) => {
        if (!email || !newPass) throw new Error('Email and password are required');
        return await apiRequest('/admin/reset-password', {
          method: 'POST',
          body: JSON.stringify({ email, password: newPass })
        });
      };
      
      const getBanners = async () => {
        return await apiRequest('/admin/banners');
      };
      
      const updateBanners = async (banners) => {
        return await apiRequest('/admin/banners', {
          method: 'PUT',
          body: JSON.stringify(banners)
        });
      };
      
      const getAccessControl = async () => {
        return await apiRequest('/admin/access-control');
      };
      
      const updateAccessControl = async (acl) => {
        return await apiRequest('/admin/access-control', {
          method: 'PUT',
          body: JSON.stringify(acl)
        });
      };
      
      // Check if user can access a specific page
      const canAccessPage = (user, pageId) => {
        if (!user) return false;
        
        // Admin can access all pages
        if (isAdmin(user)) return true;
        
        // Check if page is in user's default role pages
        const page = PAGES[pageId];
        if (page && page.roles.includes(user.role)) {
          return true;
        }
        
        return false;
      };
      
      // Router
      const pages = {
        index: 'page-index',
        'register-options': 'page-register-options',
        login: 'page-login',
        'register-shipper': 'page-register-shipper',
        'register-transporter': 'page-register-transporter',
        'shipper-dashboard': 'page-shipper-dashboard',
        'shipper-post': 'page-shipper-post',
        'shipper-profile': 'page-shipper-profile',
        'transporter-dashboard': 'page-transporter-dashboard',
        'transporter-profile': 'page-transporter-profile',
        'market': 'page-market',
        messages: 'page-messages',
        control: 'page-control'
      };
      
      const show = hash => {
        const key = (hash || '#').replace('#', '') || 'index';
        for (const k in pages) {
          const element = el(pages[k]);
          if (element) element.classList.add('hidden');
        }
        const activePage = el(pages[key]);
        if (activePage) {
          activePage.classList.remove('hidden');
          // Set focus to the main heading for accessibility
          const heading = activePage.querySelector('h1, h2');
          if (heading) heading.focus();
        }
        render();
      };
      
      // Rendering functions
      const renderHeader = async () => {
        const u = await getCurrentUser();
        setHidden('btnLogout', !u);
        setHidden('btnLoginNav', !!u);
        setText('authUser', u ? `${sanitize(u.name)} Â· ${u.role}` : '');
        
        const chip = el('roleChip');
        if (u) {
          chip.textContent = u.role.toUpperCase();
          chip.classList.remove('hidden');
        } else {
          chip.classList.add('hidden');
        }
        
        // Render navigation links
        const navLinksContainer = el('navLinks');
        if (navLinksContainer) {
          navLinksContainer.innerHTML = '';
          
          if (u) {
            // Add navigation links based on user access
            Object.keys(PAGES).forEach(pageId => {
              if (canAccessPage(u, pageId)) {
                const link = document.createElement('a');
                link.href = `#${pageId}`;
                link.className = 'btn';
                link.textContent = PAGES[pageId].name;
                navLinksContainer.appendChild(link);
              }
            });
          }
        }
      };
      
      const renderBanners = async () => {
        try {
          const banners = await getBanners();
          
          const i = el('indexBanner');
          if (i) {
            i.textContent = sanitize(banners.index) || '';
            setHidden('indexBanner', !banners.index);
          }
          
          const u = await getCurrentUser();
          const d1 = el('dashBannerShipper');
          const d2 = el('dashBannerTransporter');
          const m = el('marketBanner');
          
          if (d1) {
            d1.textContent = sanitize(banners.dashboard) || '';
            setHidden('dashBannerShipper', !banners.dashboard);
          }
          
          if (d2) {
            d2.textContent = sanitize(banners.dashboard) || '';
            setHidden('dashBannerTransporter', !banners.dashboard);
          }
          
          if (m) {
            m.textContent = sanitize(banners.dashboard) || '';
            setHidden('marketBanner', !banners.dashboard);
          }
          
          // Preload admin form fields
          if (isAdmin(u)) {
            const adminIndexBanner = el('adminIndexBanner');
            const adminDashBanner = el('adminDashBanner');
            if (adminIndexBanner) adminIndexBanner.value = banners.index || '';
            if (adminDashBanner) adminDashBanner.value = banners.dashboard || '';
          }
        } catch (error) {
          console.error('Failed to load banners:', error);
        }
      };
      
      const renderShipper = async () => {
        const u = await getCurrentUser();
        if (!u) return;
        
        try {
          // Get access control data
          const acl = await getAccessControl();
          
          // Post access chip
          const allow = acl.post && acl.post[u.email];
          setText('shipperPostAccessChip', allow ? 'Post access: ENABLED' : 'Post access: DISABLED');
          
          // My loads table
          const rows = await getLoads({ shipper_id: u.id });
          const tb = el('tableMyLoads');
          if (!tb) return;
          
          const tbody = tb.querySelector('tbody');
          if (!tbody) return;
          
          tbody.innerHTML = '';
          
          if (rows.length === 0) {
            const emptyRow = document.createElement('tr');
            emptyRow.innerHTML = '<td colspan="9" style="text-align:center">No loads posted yet</td>';
            tbody.appendChild(emptyRow);
            return;
          }
          
          for (const l of rows) {
            const expired = isLoadExpired(l);
            const expiryDate = l.expires_at ? new Date(l.expires_at).toLocaleDateString() : 'N/A';
            
            const tr = document.createElement('tr');
            if (expired) tr.classList.add('expired');
            
            tr.innerHTML = `
              <td>${sanitize(l.ref)}</td>
              <td>${sanitize(l.origin)}</td>
              <td>${sanitize(l.destination)}</td>
              <td>${sanitize(l.date)}</td>
              <td>${expiryDate}</td>
              <td>${sanitize(l.cargo_type)}</td>
              <td>${sanitize(l.weight)}</td>
              <td>${sanitize(l.notes || '')}</td>
              <td>
                <button class="btn" data-edit="${l.id}" aria-label="Edit load ${l.ref}">Edit</button>
                <button class="btn danger" data-del="${l.id}" aria-label="Delete load ${l.ref}">Delete</button>
              </td>`;
            tbody.appendChild(tr);
          }
          
          // Action handlers
          tbody.querySelectorAll('[data-del]').forEach(b => {
            b.onclick = () => {
              if (confirm('Are you sure you want to delete this load?')) {
                handleError(async () => {
                  await deleteLoad(b.dataset.del);
                  render();
                }, 'Failed to delete load');
              }
            };
          });
          
          tbody.querySelectorAll('[data-edit]').forEach(b => {
            b.onclick = () => {
              const l = rows.find(x => x.id === b.dataset.edit);
              if (!l) return;
              
              const origin = prompt('Origin', l.origin);
              if (origin === null) return;
              
              const destination = prompt('Destination', l.destination);
              if (destination === null) return;
              
              const date = prompt('Date (YYYY-MM-DD)', l.date);
              if (date === null) return;
              
              const cargo_type = prompt('Cargo', l.cargo_type);
              if (cargo_type === null) return;
              
              const weight = prompt('Weight', l.weight);
              if (weight === null) return;
              
              const notes = prompt('Notes', l.notes || '');
              if (notes === null) return;
              
              handleError(async () => {
                await updateLoad(l.id, { origin, destination, date, cargo_type, weight, notes });
                render();
              }, 'Failed to update load');
            };
          });
          
          // Post page access notice
          const notice = el('postAccessNotice');
          if (notice) {
            notice.textContent = allow ? '' : 'Admin has disabled your Post Load access.';
            setHidden('postAccessNotice', allow);
          }
        } catch (error) {
          console.error('Failed to render shipper dashboard:', error);
        }
      };
      
      const renderTransporter = async () => {
        const u = await getCurrentUser();
        if (!u) return;
        
        try {
          // Get access control data
          const acl = await getAccessControl();
          
          const allow = acl.market && acl.market[u.email];
          setText('marketAccessChip', allow ? 'Market access: ENABLED' : 'Market access: DISABLED');
          
          const tb = el('tableLoads');
          if (!tb) return;
          
          const tbody = tb.querySelector('tbody');
          if (!tbody) return;
          
          tbody.innerHTML = '';
          
          // Get filters
          const fo = el('filterOrigin');
          const fd = el('filterDest');
          
          // Only show non-expired loads to users with market access
          const filters = {};
          if (fo && fo.value.trim()) filters.origin = fo.value.trim();
          if (fd && fd.value.trim()) filters.destination = fd.value.trim();
          
          let rows = allow ? await getLoads(filters) : [];
          
          // Filter out expired loads
          rows = rows.filter(l => !isLoadExpired(l));
          
          if (rows.length === 0) {
            const emptyRow = document.createElement('tr');
            emptyRow.innerHTML = '<td colspan="9" style="text-align:center">No loads available</td>';
            tbody.appendChild(emptyRow);
            return;
          }
          
          for (const l of rows) {
            const expiryDate = l.expires_at ? new Date(l.expires_at).toLocaleDateString() : 'N/A';
            
            const tr = document.createElement('tr');
            tr.innerHTML = `
              <td>${sanitize(l.ref)}</td>
              <td>${sanitize(l.origin)}</td>
              <td>${sanitize(l.destination)}</td>
              <td>${sanitize(l.date)}</td>
              <td>${expiryDate}</td>
              <td>${sanitize(l.cargo_type)}</td>
              <td>${sanitize(l.weight)}</td>
              <td>${sanitize(l.notes || '')}</td>
              <td>${sanitize(l.shipper_email || '')}</td>`;
            tbody.appendChild(tr);
          }
        } catch (error) {
          console.error('Failed to render transporter dashboard:', error);
        }
      };
      
      const renderMarket = async () => {
        const u = await getCurrentUser();
        if (!u) return;
        
        try {
          // Get access control data
          const acl = await getAccessControl();
          
          // Only show non-expired loads to users with market access
          const allow = acl.market && acl.market[u.email];
          
          // Get filters
          const fo = el('marketFilterOrigin');
          const fd = el('marketFilterDest');
          
          const filters = {};
          if (fo && fo.value.trim()) filters.origin = fo.value.trim();
          if (fd && fd.value.trim()) filters.destination = fd.value.trim();
          
          let rows = allow ? await getLoads(filters) : [];
          
          // Filter out expired loads
          rows = rows.filter(l => !isLoadExpired(l));
          
          const tb = el('tableMarketLoads');
          if (!tb) return;
          
          const tbody = tb.querySelector('tbody');
          if (!tbody) return;
          
          tbody.innerHTML = '';
          
          if (rows.length === 0) {
            const emptyRow = document.createElement('tr');
            emptyRow.innerHTML = '<td colspan="9" style="text-align:center">No loads available</td>';
            tbody.appendChild(emptyRow);
            return;
          }
          
          for (const l of rows) {
            const expiryDate = l.expires_at ? new Date(l.expires_at).toLocaleDateString() : 'N/A';
            
            const tr = document.createElement('tr');
            tr.innerHTML = `
              <td>${sanitize(l.ref)}</td>
              <td>${sanitize(l.origin)}</td>
              <td>${sanitize(l.destination)}</td>
              <td>${sanitize(l.date)}</td>
              <td>${expiryDate}</td>
              <td>${sanitize(l.cargo_type)}</td>
              <td>${sanitize(l.weight)}</td>
              <td>${sanitize(l.notes || '')}</td>
              <td>${sanitize(l.shipper_email || '')}</td>`;
            tbody.appendChild(tr);
          }
        } catch (error) {
          console.error('Failed to render market:', error);
        }
      };
      
      const renderProfiles = async () => {
        const u = await getCurrentUser();
        if (!u) return;
        
        // Update profile header
        if (u.role === 'shipper') {
          const avatar = el('shipperProfileAvatar');
          const name = el('shipperProfileName');
          const since = el('shipperProfileSince');
          
          if (avatar) avatar.textContent = u.name.charAt(0).toUpperCase();
          if (name) name.textContent = u.name;
          if (since) since.textContent = new Date(u.created_at).toLocaleDateString('en-US', { year: 'numeric', month: 'long' });
          
          // Update profile details
          setText('shipperProfileEmail', u.email);
          setText('shipperProfileCompany', u.company || 'Not provided');
          setText('shipperProfileRole', u.role.charAt(0).toUpperCase() + u.role.slice(1));
          setText('shipperProfileCreated', new Date(u.created_at).toLocaleDateString('en-US', { year: 'numeric', month: 'long' }));
        }
        
        if (u.role === 'transporter') {
          const avatar = el('transporterProfileAvatar');
          const name = el('transporterProfileName');
          const since = el('transporterProfileSince');
          
          if (avatar) avatar.textContent = u.name.charAt(0).toUpperCase();
          if (name) name.textContent = u.name;
          if (since) since.textContent = new Date(u.created_at).toLocaleDateString('en-US', { year: 'numeric', month: 'long' });
          
          // Update profile details
          setText('transporterProfileEmail', u.email);
          setText('transporterProfileCompany', u.company || 'Not provided');
          setText('transporterProfileVehicle', u.vehicle_info || 'Not provided');
          setText('transporterProfileRole', u.role.charAt(0).toUpperCase() + u.role.slice(1));
          setText('transporterProfileCreated', new Date(u.created_at).toLocaleDateString('en-US', { year: 'numeric', month: 'long' }));
        }
        
        const fields = (user, role) => {
          const base = `
            <div class="grid two">
              <div><label for="${role}Name">Contact Person (Name)</label><input required id="${role}Name" name="name" value="${sanitize(user.name || '')}" /></div>
              <div><label for="${role}Phone">Phone</label><input id="${role}Phone" name="phone" value="${sanitize(user.phone || '')}" /></div>
              <div class="two" style="grid-column:1/-1"><label for="${role}Address">Address</label><input id="${role}Address" name="address" value="${sanitize(user.address || '')}" /></div>
              <div><label for="${role}Password">Password</label><input id="${role}Password" name="password" type="password" value="${user.password || ''}" /></div>
            </div>`;
          return base;
        };
        
        if (u.role === 'shipper') {
          const form = el('formProfileShipper');
          if (form) form.innerHTML = fields(u, 'shipper');
        }
        
        if (u.role === 'transporter') {
          const form = el('formProfileTransporter');
          if (form) form.innerHTML = fields(u, 'transporter');
        }
      };
      
      const renderMessages = async () => {
        const u = await getCurrentUser();
        if (!u) return;
        
        try {
          const tb = el('tableInbox');
          if (!tb) return;
          
          const tbody = tb.querySelector('tbody');
          if (!tbody) return;
          
          tbody.innerHTML = '';
          
          const messages = await getMessages();
          
          if (messages.length === 0) {
            const emptyRow = document.createElement('tr');
            emptyRow.innerHTML = '<td colspan="4" style="text-align:center">No messages</td>';
            tbody.appendChild(emptyRow);
            return;
          }
          
          for (const m of messages) {
            const tr = document.createElement('tr');
            const d = new Date(m.created_at).toLocaleString();
            tr.innerHTML = `
              <td>${sanitize(m.sender_email || 'Unknown')}</td>
              <td>${sanitize(m.body)}</td>
              <td>${sanitize(d)}</td>
              <td><button class="btn" data-delmsg="${m.id}" aria-label="Delete message">Delete</button></td>`;
            tbody.appendChild(tr);
          }
          
          tbody.querySelectorAll('[data-delmsg]').forEach(b => {
            b.onclick = () => {
              handleError(async () => {
                await deleteMessage(b.dataset.delmsg);
                render();
              }, 'Failed to delete message');
            };
          });
        } catch (error) {
          console.error('Failed to render messages:', error);
        }
      };
      
      const renderAdmin = async () => {
        const u = await getCurrentUser();
        if (!isAdmin(u)) return;
        
        try {
          // Populate user dropdown for page access control
          const userSelect = el('pageAccessUser');
          if (userSelect) {
            const users = await getUsers();
            userSelect.innerHTML = '<option value="">-- Select User --</option>';
            
            users.forEach(user => {
              if (user.role !== 'admin') { // Exclude admin from the list
                const option = document.createElement('option');
                option.value = user.email;
                option.textContent = `${user.name} (${user.email})`;
                userSelect.appendChild(option);
              }
            });
            
            // Add change event listener
            userSelect.onchange = () => {
              renderPageAccessCheckboxes(userSelect.value);
            };
          }
          
          // Users table
          const tbU = el('tableUsers');
          if (tbU) {
            const users = await getUsers();
            const acl = await getAccessControl();
            
            const tbodyU = tbU.querySelector('tbody');
            if (tbodyU) {
              tbodyU.innerHTML = '';
              
              for (const usr of users) {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                  <td>${sanitize(usr.name)}</td>
                  <td>${sanitize(usr.email)}</td>
                  <td>${sanitize(usr.role)}</td>
                  <td>
                    <button class="btn" data-grant-post="${usr.email}" aria-label="Grant post access to ${usr.email}">Grant Post</button>
                    <button class="btn" data-revoke-post="${usr.email}" aria-label="Revoke post access from ${usr.email}">Revoke Post</button>
                    <button class="btn" data-grant-market="${usr.email}" aria-label="Grant market access to ${usr.email}">Grant Market</button>
                    <button class="btn" data-revoke-market="${usr.email}" aria-label="Revoke market access from ${usr.email}">Revoke Market</button>
                    <button class="btn danger" data-deluser="${usr.email}" aria-label="Delete user ${usr.email}">Delete</button>
                  </td>`;
                tbodyU.appendChild(tr);
              }
              
              tbodyU.querySelectorAll('[data-deluser]').forEach(b => {
                b.onclick = () => {
                  if (confirm('Are you sure you want to delete this user? This will also delete all their associated data.')) {
                    handleError(async () => {
                      await deleteUser(b.dataset.deluser);
                      render();
                    }, 'Failed to delete user');
                  }
                };
              });
              
              tbodyU.querySelectorAll('[data-grant-post]').forEach(b => {
                b.onclick = async () => {
                  const acl = await getAccessControl();
                  if (!acl.post) acl.post = {};
                  acl.post[b.dataset.grantPost] = true;
                  await updateAccessControl(acl);
                  render();
                };
              });
              
              tbodyU.querySelectorAll('[data-revoke-post]').forEach(b => {
                b.onclick = async () => {
                  const acl = await getAccessControl();
                  if (acl.post && acl.post[b.dataset.revokePost]) {
                    delete acl.post[b.dataset.revokePost];
                    await updateAccessControl(acl);
                    render();
                  }
                };
              });
              
              tbodyU.querySelectorAll('[data-grant-market]').forEach(b => {
                b.onclick = async () => {
                  const acl = await getAccessControl();
                  if (!acl.market) acl.market = {};
                  acl.market[b.dataset.grantMarket] = true;
                  await updateAccessControl(acl);
                  render();
                };
              });
              
              tbodyU.querySelectorAll('[data-revoke-market]').forEach(b => {
                b.onclick = async () => {
                  const acl = await getAccessControl();
                  if (acl.market && acl.market[b.dataset.revokeMarket]) {
                    delete acl.market[b.dataset.revokeMarket];
                    await updateAccessControl(acl);
                    render();
                  }
                };
              });
            }
          }
          
          // Loads table
          const tbL = el('tableAllLoads');
          if (tbL) {
            const loads = await getLoads();
            const tbodyL = tbL.querySelector('tbody');
            if (tbodyL) {
              tbodyL.innerHTML = '';
              
              for (const l of loads) {
                const expired = isLoadExpired(l);
                const expiryDate = l.expires_at ? new Date(l.expires_at).toLocaleDateString() : 'N/A';
                
                const tr = document.createElement('tr');
                if (expired) tr.classList.add('expired');
                
                tr.innerHTML = `
                  <td>${sanitize(l.ref)}</td>
                  <td>${sanitize(l.origin)}</td>
                  <td>${sanitize(l.destination)}</td>
                  <td>${sanitize(l.date)}</td>
                  <td>${expiryDate}</td>
                  <td>${sanitize(l.cargo_type)}</td>
                  <td>${sanitize(l.weight)}</td>
                  <td>${sanitize(l.shipper_email || '')}</td>
                  <td>
                    <button class="btn" data-editl="${l.id}" aria-label="Edit load ${l.ref}">Edit</button>
                    <button class="btn danger" data-dell="${l.id}" aria-label="Delete load ${l.ref}">Delete</button>
                  </td>`;
                tbodyL.appendChild(tr);
              }
              
              tbodyL.querySelectorAll('[data-dell]').forEach(b => {
                b.onclick = () => {
                  if (confirm('Are you sure you want to delete this load?')) {
                    handleError(async () => {
                      await deleteLoad(b.dataset.dell);
                      render();
                    }, 'Failed to delete load');
                  }
                };
              });
              
              tbodyL.querySelectorAll('[data-editl]').forEach(b => {
                b.onclick = () => {
                  const l = loads.find(x => x.id === b.dataset.editl);
                  if (!l) return;
                  
                  const origin = prompt('Origin', l.origin);
                  if (origin === null) return;
                  
                  const destination = prompt('Destination', l.destination);
                  if (destination === null) return;
                  
                  const date = prompt('Date (YYYY-MM-DD)', l.date);
                  if (date === null) return;
                  
                  const cargo_type = prompt('Cargo', l.cargo_type);
                  if (cargo_type === null) return;
                  
                  const weight = prompt('Weight', l.weight);
                  if (weight === null) return;
                  
                  const notes = prompt('Notes', l.notes || '');
                  if (notes === null) return;
                  
                  handleError(async () => {
                    await updateLoad(l.id, { origin, destination, date, cargo_type, weight, notes });
                    render();
                  }, 'Failed to update load');
                };
              });
            }
          }
        } catch (error) {
          console.error('Failed to render admin panel:', error);
        }
      };
      
      // Render page access checkboxes for a specific user
      const renderPageAccessCheckboxes = async (email) => {
        const container = el('pageAccessCheckboxes');
        if (!container || !email) {
          container.innerHTML = '';
          return;
        }
        
        container.innerHTML = '';
        
        // Get current page access for this user
        const acl = await getAccessControl();
        const userPages = (acl.pages && acl.pages[email]) || {};
        
        // Create checkboxes for each page
        Object.keys(PAGES).forEach(pageId => {
          // Skip admin control page for non-admin users
          if (pageId === 'control') return;
          
          const checkboxItem = document.createElement('div');
          checkboxItem.className = 'checkbox-item';
          
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.id = `page_${pageId}`;
          checkbox.value = pageId;
          checkbox.checked = !!userPages[pageId];
          
          const label = document.createElement('label');
          label.htmlFor = `page_${pageId}`;
          label.textContent = PAGES[pageId].name;
          
          checkboxItem.appendChild(checkbox);
          checkboxItem.appendChild(label);
          container.appendChild(checkboxItem);
        });
      };
      
      const render = async () => {
        await renderHeader();
        await renderBanners();
        
        const u = await getCurrentUser();
        
        // Auth guard: if on restricted page and not logged in -> login
        const restricted = ['shipper-dashboard', 'shipper-post', 'shipper-profile', 'transporter-dashboard', 'transporter-profile', 'market', 'messages', 'control'];
        const page = (location.hash || '#').replace('#', '') || 'index';
        
        if (!u && restricted.includes(page)) {
          location.hash = '#login';
          return;
        }
        
        // Check if user has access to the current page
        if (u && !canAccessPage(u, page)) {
          // If the user is an admin, they can access everything, so this shouldn't happen.
          // For non-admin, redirect to their role's dashboard or index?
          if (u.role === 'shipper') {
            location.hash = '#shipper-dashboard';
          } else if (u.role === 'transporter') {
            location.hash = '#transporter-dashboard';
          } else {
            location.hash = '#index';
          }
          return;
        }
        
        if (u) {
          // Role routing
          if (page === 'index') {
            if (u.role === 'shipper') location.hash = '#shipper-dashboard';
            else if (u.role === 'transporter') location.hash = '#transporter-dashboard';
            else if (isAdmin(u)) location.hash = '#control';
          }
          
          if (page.startsWith('shipper')) await renderShipper();
          if (page.startsWith('transporter')) await renderTransporter();
          if (page === 'market') await renderMarket();
          if (page === 'messages') await renderMessages();
          if (page === 'shipper-profile' || page === 'transporter-profile') await renderProfiles();
          if (page === 'control') {
            if (!isAdmin(u)) {
              location.hash = '#login';
              return;
            }
            await renderAdmin();
          }
        }
      };
      
      // Event bindings
      const initEventListeners = () => {
        // Logout
        const btnLogout = el('btnLogout');
        if (btnLogout) btnLogout.onclick = logout;
        
        // Login form
        const formLogin = el('formLogin');
        if (formLogin) {
          formLogin.onsubmit = async e => {
            e.preventDefault();
            const fd = new FormData(e.target);
            const email = fd.get('email');
            const password = fd.get('password');
            
            if (!email || !password) {
              alert('Please enter both email and password');
              return;
            }
            
            const user = await login(email, password);
            if (!user) {
              alert('Invalid credentials');
              return;
            }
            
            if (user.role === 'shipper') location.hash = '#shipper-dashboard';
            else if (user.role === 'transporter') location.hash = '#transporter-dashboard';
            else if (isAdmin(user)) location.hash = '#control';
          };
        }
        
        // Shipper registration form
        const formRegShipper = el('formRegShipper');
        if (formRegShipper) {
          formRegShipper.onsubmit = async e => {
            e.preventDefault();
            const fd = new FormData(e.target);
            
            handleError(async () => {
              await registerUser({
                name: fd.get('name'),
                company: fd.get('company'),
                email: fd.get('email'),
                phone: fd.get('phone'),
                password: fd.get('password'),
                address: fd.get('address'),
                role: 'shipper'
              });
              alert('Shipper registered. Please login.');
              location.hash = '#login';
            }, 'Registration failed');
          };
        }
        
        // Transporter registration form
        const formRegTransporter = el('formRegTransporter');
        if (formRegTransporter) {
          formRegTransporter.onsubmit = async e => {
            e.preventDefault();
            const fd = new FormData(e.target);
            
            handleError(async () => {
              await registerUser({
                name: fd.get('name'),
                company: fd.get('company'),
                email: fd.get('email'),
                phone: fd.get('phone'),
                password: fd.get('password'),
                address: fd.get('address'),
                vehicle_info: fd.get('vehicle_info'),
                role: 'transporter'
              });
              alert('Transporter registered. Please login.');
              location.hash = '#login';
            }, 'Registration failed');
          };
        }
        
        // Post load form
        const formPostLoad = el('formPostLoad');
        if (formPostLoad) {
          formPostLoad.onsubmit = async e => {
            e.preventDefault();
            const fd = new FormData(e.target);
            const u = await getCurrentUser();
            
            if (!u) return;
            
            try {
              const acl = await getAccessControl();
              if (!acl.post || !acl.post[u.email]) {
                alert('Your Post Load access is disabled by Admin.');
                return;
              }
            } catch (error) {
              console.error('Failed to check access control:', error);
              alert('Failed to verify access permissions');
              return;
            }
            
            handleError(async () => {
              await postLoad({
                origin: fd.get('origin'),
                destination: fd.get('destination'),
                date: fd.get('date'),
                cargo_type: fd.get('cargo_type'),
                weight: fd.get('weight'),
                notes: fd.get('notes')
              });
              alert('Load published successfully. It will expire in 7 days.');
              e.target.reset();
              location.hash = '#shipper-dashboard';
            }, 'Failed to post load');
          };
        }
        
        // Save shipper profile
        const saveProfileShipper = el('saveProfileShipper');
        if (saveProfileShipper) {
          saveProfileShipper.onclick = async () => {
            const u = await getCurrentUser();
            if (!u) return;
            
            const f = el('formProfileShipper');
            if (!f) return;
            
            handleError(async () => {
              const data = Object.fromEntries(new FormData(f).entries());
              await updateUserProfile(u.id, data);
              alert('Contact information updated successfully');
              render();
            }, 'Failed to save profile');
          };
        }
        
        // Save transporter profile
        const saveProfileTransporter = el('saveProfileTransporter');
        if (saveProfileTransporter) {
          saveProfileTransporter.onclick = async () => {
            const u = await getCurrentUser();
            if (!u) return;
            
            const f = el('formProfileTransporter');
            if (!f) return;
            
            handleError(async () => {
              const data = Object.fromEntries(new FormData(f).entries());
              await updateUserProfile(u.id, data);
              alert('Contact information updated successfully');
              render();
            }, 'Failed to save profile');
          };
        }
        
        // Filter loads
        const btnFilterLoads = el('btnFilterLoads');
        if (btnFilterLoads) {
          btnFilterLoads.onclick = e => {
            e.preventDefault();
            renderTransporter();
          };
        }
        
        // Filter market loads
        const btnMarketFilterLoads = el('btnMarketFilterLoads');
        if (btnMarketFilterLoads) {
          btnMarketFilterLoads.onclick = e => {
            e.preventDefault();
            renderMarket();
          };
        }
        
        // Send message form
        const formSendMsg = el('formSendMsg');
        if (formSendMsg) {
          formSendMsg.onsubmit = async e => {
            e.preventDefault();
            const fd = new FormData(e.target);
            
            handleError(async () => {
              await sendMessage(fd.get('to').trim(), fd.get('body').trim());
              e.target.reset();
              renderMessages();
            }, 'Failed to send message');
          };
        }
        
        // Admin controls
        const btnSaveBanners = el('btnSaveBanners');
        if (btnSaveBanners) {
          btnSaveBanners.onclick = async () => {
            const banners = {
              index: el('adminIndexBanner').value || '',
              dashboard: el('adminDashBanner').value || ''
            };
            await updateBanners(banners);
            render();
          };
        }
        
        const btnClearBanners = el('btnClearBanners');
        if (btnClearBanners) {
          btnClearBanners.onclick = async () => {
            await updateBanners({ index: '', dashboard: '' });
            render();
          };
        }
        
        const btnResetPass = el('btnResetPass');
        if (btnResetPass) {
          btnResetPass.onclick = async () => {
            const email = el('resetEmail').value.trim();
            const p = el('resetPass').value;
            
            handleError(async () => {
              await resetPassword(email, p);
              alert('Password updated');
            }, 'Failed to reset password');
          };
        }
        
        // Save page access
        const btnSavePageAccess = el('btnSavePageAccess');
        if (btnSavePageAccess) {
          btnSavePageAccess.onclick = async () => {
            const email = el('pageAccessUser').value;
            if (!email) {
              alert('Please select a user');
              return;
            }
            
            const pageAccess = {};
            const checkboxes = el('pageAccessCheckboxes').querySelectorAll('input[type="checkbox"]');
            
            checkboxes.forEach(checkbox => {
              pageAccess[checkbox.value] = checkbox.checked;
            });
            
            handleError(async () => {
              const acl = await getAccessControl();
              if (!acl.pages) acl.pages = {};
              acl.pages[email] = pageAccess;
              await updateAccessControl(acl);
              alert('Page access updated successfully');
            }, 'Failed to update page access');
          };
        }
        
        // Top nav buttons
        const btnLoginNav = el('btnLoginNav');
        if (btnLoginNav) {
          btnLoginNav.onclick = () => {
            location.hash = '#login';
          };
        }
      };
      
      // Initialize the app
      const init = () => {
        // Set up hash change listener
        window.addEventListener('hashchange', () => show(location.hash));
        
        // Initialize event listeners
        initEventListeners();
        
        // Initial render
        show(location.hash);
        
        // Add error handler for uncaught errors
        window.addEventListener('error', event => {
          console.error('Uncaught error:', event.error);
          // Prevent default error handling
          event.preventDefault();
        });
      };
      
      // Start the app when DOM is ready
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }
    })();
  </script>
